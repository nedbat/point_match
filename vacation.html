<!DOCTYPE html> <!-- vim: set foldmethod=marker foldlevel=0 cc=60 :-->
<!--

Process this file with cog:

    $ pip install -r requirements.txt
    $ python -m cogapp -r vacation.html

-->
<html>
<!-- *** Head stuff {{{ -->
<!--[[[cog
import cog
from cogutil import *
]]]-->
<!--[[[end]]]-->
<head>
<title>What I Did on my Summer Vacation</title>
<meta charset="utf-8" />

    <!-- *** Includes {{{ -->
    <!-- Slippy core file and dependencies -->
    <script type="text/javascript" src="slippy/jquery.min.js"></script>
    <script type="text/javascript" src="slippy/jquery.history.js"></script>
    <script type="text/javascript" src="slippy/slippy.js"></script>
    <script src="https://cdn.rawgit.com/ekalinin/typogr.js/0.6.6/typogr.min.js"></script>

    <!-- Slippy structural styles -->
    <link type="text/css" rel="stylesheet" href="slippy/slippy.css"/>
    <!-- Slippy theme -->
    <link type="text/css" rel="stylesheet" href="slippy/slippy-pure.css"/>
    <!-- Our styles -->
    <link type="text/css" rel="stylesheet" href="slides.css"/>

    <!-- Highlight, for syntax coloring. -->
    <script type="text/javascript" src="highlight/highlight.pack.js"></script>
    <link rel="stylesheet" href="highlight/vs.css">

    <script type="text/javascript" src="lineselect.js"></script>

    <!-- http://html.adobe.com/edge/webfonts/ -->
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800' rel='stylesheet' type='text/css'>
    <!-- }}} -->

    <!-- *** Init code {{{ -->
    <script type="text/javascript">
        $(function() {
            if ($("body.slides").length) {
                // Visit vacation.html?showall to see all the incremental stuff at once...
                var showall = (window.location.href.indexOf("showall") !== -1);
                $(".slide").slippy({
                    // settings go here
                    // possible values are:
                    //  - animLen, duration for default animations (0 = disabled)
                    //  - animInForward, receives a slide and animates it
                    //  - animInRewind, receives a slide and animates it
                    //  - animOutForward, receives a slide and animates it
                    //  - animOutRewind, receives a slide and animates it
                    //  - baseWidth, defines the base for img resizing, if you don't want only
                    //    full-width images, specify this as the pixel width of a slide so that
                    //    images are scaled properly (default is 620px wide)
                    //  - ratio, defines the width/height ratio of the slides, defaults to 1.3 (620x476)
                    //  - margin, the fraction of screen to use as slide margin, defaults to 0.15
                    margin: 0.01,
                    baseWidth: false,   // disable all active image resizing
                    incrementalBefore: function (el) {
                        if (!showall) {
                            $(el).css({ opacity: 0.01 });
                        }
                    },
                    animInForward: function (slide) {
                        var slide = $(slide);
                        if (slide.hasClass("fadein")) {
                            slide.css('opacity', '0').css('left', '50%').animate({opacity: '1'}, 650);
                        }
                        else {
                            slide.css('left', '150%').animate({left: '50%'}, 350);
                        }
                        if (!showall) {
                            slide.find(".incremental").css({opacity:0});    // IDK why this hides them, but 0.01 does not.
                        }
                    },
                    animOutForward: function(slide) {
                        var slide = $(slide);
                        if (slide.hasClass("fadeout")) {
                            slide.animate({opacity: '1'}, 650).animate({left: '-50%'}, 0);
                        }
                        else {
                            slide.animate({left: '-50%'}, 350);
                        }
                    }
                });
            }

            // Highlight the code in <pre> blocks.
            $('pre').each(function (i, e) {
                hljs.highlightBlock(e, '    ');
            });

            // Convert <pre> to have <span class='line'> for each line.
            $('pre').each(function (i, e) {
                var $e = $(e);
                var lines = $e.html().split("\n");
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    if (line === "") {
                        lines[i] = "<span class='blankline'>&nbsp;</span>";
                    }
                    else {
                        lines[i] = "<span class='line'>" + lines[i] + "</span>";
                    }
                }
                $e.html(lines.join("\n"));
            });

            $("div.slide").lineselect({ lines: "pre span.line" });

            // Pre-select lines based on a select= attribute.
            $('pre').each(function (i, e) {
                var $e = $(e);
                var select = $e.attr("select");
                if (select) {
                    $e.lineselect(select);
                }
            });

            // Make all the English text look nicer.
            $('h1, h2, h3, li, p').each(function (i, e) {
                var $e = $(e);
                $e.html(typogr.typogrify($e));
            });
        });
    </script>
    <!-- }}} -->

    <!-- *** Custom style for this deck {{{ -->
    <style type="text/css">
    .slide.image {
        text-align: center;
    }
    .slide.section label {
        color: #888;
        font-style: italic;
        font-size: 85%;
        display: block;
    }
    .o_1 {
        background: #3f3;
        border-radius: .15em;
    }
    .o_n {
        background: #fbb;
        border-radius: .15em;
    }
    .popup {
        background: white;
        position: absolute;
        border: .75em solid #f66;
        border-radius: 1em;
        box-shadow: .35em .35em .2em rgba(0, 0, 0, 0.4);
    }
    div.popup {
        padding: .6em 2em;
    }
    </style>
    <!-- }}} -->

</head>
<!-- }}} -->
<body class="slides">

<div class="slide title" data-layout="clean">
    <h1>What I Did on my<br>Summer Vacation</h1>
    <h2>Ned Batchelder<br/><a class="implicit" href="https://twitter.com/nedbat"><span class="punct">@</span>nedbat</a></h2>
    <h2><a class="implicit" href="https://bit.ly/bospyvaca"><span class="punct">https://</span>bit.ly<span class="punct">/</span>bospyvaca</a></h2>
</div>

<div class="text"><!-- {{{ -->

<p>Blah blah blah.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>What am I talking about?</h1>
    <ul>
    <li class="incremental">Side project: <a href='https://github.com/nedbat/zellij'>Zellij</a>
        <ul>
            <li>(skip the geometry if you want)</li>
        </ul>
    </li>
    <li class="incremental">Challenges and solutions</li>
    <li class="incremental">Concepts, techniques, advice</li>
    <li class="incremental">Questions are OK!</li>
    </ul>
</div>

<div class="slide">
    <h1>Software is hard</h1>
    <ul>
    <li class="incremental">Lots of challenges</li>
    <li class="incremental">Even small projects have tricky questions</li>
    <li class="incremental">"Experts" are not immune</li>
    </ul>
</div>

<div class="slide">
    <h1>We're all in this together</h1>
    <img class='fullwidth incremental' src='noidea1.jpg' />
</div>

<div class="slide image" data-layout="clean">
    <img class='fullheight' src='twostates.jpg' />
</div>

<div class="slide section" data-layout="clean">
    <h1><label>Prelude</label> My Vacation</h1>
</div>

<!--[[[cog
import glob
def pic_sequence(pix):
    for i, (pic, imgclass) in enumerate(pix):
        cls = "slide image"
        if i > 0:
            cls += " fadein"
        if i < len(pix) - 1:
            cls += " fadeout"
        cog.outl('<div class="{}" data-layout="clean"><img src="{}" class="{}"/></div>'.format(cls, pic, imgclass))
]]]-->
<!--[[[end]]]-->

<div class="slide image" data-layout="clean"><img src="map2.png" class="fullwidth"/></div>

<!--[[[cog 
    pic_sequence([
        ('dorn_view.jpg', 'fullwidth'),
        ('dorn_balcony.jpg', 'fullwidth'),
        ('game-of-thrones-water-garden.jpg', 'fullwidth'),
        ('dorn_room.jpg', 'fullheight'),
        ('Meeting_in_dorn_jaime_myrcella.jpg', 'fullwidth'),
        ('dorn_three_stars.jpg', 'fullheight'),
        ('dorn_tile_zoom.jpg', 'fullwidth'),
    ] +
        [(pic, 'fullwidth') for pic in glob.glob('three_stars_0*.png')[:7]]
    )
]]] -->
<div class="slide image fadeout" data-layout="clean"><img src="dorn_view.jpg" class="fullwidth"/></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="dorn_balcony.jpg" class="fullwidth"/></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="game-of-thrones-water-garden.jpg" class="fullwidth"/></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="dorn_room.jpg" class="fullheight"/></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="Meeting_in_dorn_jaime_myrcella.jpg" class="fullwidth"/></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="dorn_three_stars.jpg" class="fullheight"/></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="dorn_tile_zoom.jpg" class="fullwidth"/></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="three_stars_000_start.png" class="fullwidth"/></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="three_stars_001_thin.png" class="fullwidth"/></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="three_stars_002_symmetry.png" class="fullwidth"/></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="three_stars_003_triangle.png" class="fullwidth"/></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="three_stars_004_design.png" class="fullwidth"/></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="three_stars_005_lined.png" class="fullwidth"/></div>
<div class="slide image fadein" data-layout="clean"><img src="three_stars_006_chaos.png" class="fullwidth"/></div>
<!--[[[end]]]-->

<div class="slide section" data-layout="clean">
    <h1><label>Challenge</label> Matching Points</h1>
</div>


<div class="slide" data-layout="clean">
    <h1>Ideal</h1>
    <pre class="python">
    Pt = namedtuple("Pt", "x, y")
    zigzags = [
        [Pt(10, 20), Pt(15, 21), Pt(20, 25)],
        [Pt(20, 25), Pt(30, 15), Pt(27, 25), Pt(23, 21)],
    ]
    </pre>
    <pre class="python incremental">
    zz_by_ends = {
        <span class='attn'>Pt(10, 20)</span>: [ 
            [<span class='attn'>Pt(10, 20)</span>, Pt(15, 21), Pt(20, 25)],
        ],
        <span class='attn'>Pt(20, 25)</span>: [
            [Pt(10, 20), Pt(15, 21), <span class='attn'>Pt(20, 25)</span>],
            [<span class='attn'>Pt(20, 25)</span>, Pt(30, 15), Pt(27, 25), Pt(23, 21)],
        ],
        <span class='attn'>Pt(23, 21)</span>: [
            [Pt(20, 25), Pt(30, 15), Pt(27, 25), <span class='attn'>Pt(23, 21)</span>],
        ],
    }
    </pre>
</div>

<div class="slide">
    <h1>Concept: Dicts</h1>
    <ul>
    <li class="incremental">Maps keys to values</li>
    <li class="incremental">Fast! (more later)</li>
    <li class="incremental">Anything <em>hashable</em> can be a key</li>
    </ul>
    <pre class="python incremental">
    >>> d = {}
    >>> d['hi'] = 'hello'
    >>> d['bye'] = 'goodbye'
    >>> d['hi']
    'hello'
    </pre>

</div>

<div class="slide">
    <h1>Non-string keys</h1>
    <pre class="python">
    >>> d = {}
    >>> d[17] = 23
    >>> d[17]
    23

    >>> d[(1, 2)] = 'a point'
    >>> d[(1, 2)]
    'a point'
    >>> d[(1.0, 2.0)]
    'a point'

    >>> d[Pt(10, 20)] = 'another point'
    >>> d[Pt(10, 20)]
    'another point'
    </pre>
</div>

<div class="slide">
    <h1>BUT: Same point, different values</h1>
    <pre class="python">
    zigzags = [
        [<span class='attn'>Pt(10, 20)</span>, Pt(15, 21), Pt(20, 25)],
        [Pt(20, 25), Pt(30, 15), Pt(27, 25), Pt(23, 21)],
        [<span class='attn'>Pt(10, 20.00001)</span>, Pt(15, 40)],     # !!!   :(
        ...
    ]
    </pre>
    <pre class="python incremental">
    >>> d[Pt(10, 20)] = "hey there"
    >>> d[Pt(10, 20.00001)]
    KeyError: Pt(10, 20.00001)
    </pre>
    <pre class="python incremental">
    >>> Pt(10, 20) == Pt(10, 20.00001)
    False
    >>> 20 == 20.00001
    False
    </pre>
</div>

<div class="slide">
    <h1>Concept: Floats</h1>
    <ul>
    <li class="incremental">Notoriously fuzzy</li>
    </ul>
    <pre class="python incremental">
    >>> 0.1 + 0.2 == 0.3
    False
    </pre>
    <ul>
    <li class="incremental">Base 10 vs Base 2</li>
    <li class="incremental">1/3 is inexact in base 10</li>
    <li class="incremental">1/10 is inexact in base 2</li>
    <li class="incremental">Not Python-specific</li>
    <li class="incremental">This is different: irrationals</li>
    </ul>
</div>

<div class="slide">
    <h1>Concept: Special methods</h1>
    <ul>
    <li class="incremental">"dunder" methods: __init__, __len__, __str__, ...</li>
    <li class="incremental">You: &nbsp;&nbsp;len(x)
        <ul><li>Python: &nbsp;&nbsp;x.__len__()</li></ul>
        </li>
    <li class="incremental">str(x) &nbsp;&nbsp;&nbsp;&#8801;&nbsp;&nbsp;&nbsp; x.__str__()</li>
    <li class="incremental">x == y &nbsp;&nbsp;&nbsp;&#8801;&nbsp;&nbsp;&nbsp; x.__eq__(y)</li>
    <li class="incremental">d[k] &nbsp;&nbsp;&nbsp;&#8801;&nbsp;&nbsp;&nbsp; d.__getitem__(k)</li>
    <li class="incremental">"magic"? ☹</li>
    </ul>
</div>

<div class="slide">
    <h1>Fuzzy equality</h1>
    <pre class="python">
    class Pt(namedtuple("Pt", "x, y")):

        def __eq__(self, other):
            x1, y1 = self
            x2, y2 = other
            return (
                math.isclose(x1, x2) and
                math.isclose(y1, y2)
            )
    </pre>
    <ul><li class="incremental">Foreshadowing: this is a bad idea!</li></ul>
</div>

<div class="slide">
    <h1>Concept: Hashing</h1>
    <ul>
    <li class="incremental">A short-cut for ==</li>
    <li class="incremental">Rules:<ul>
        <li class="incremental">hash() must return an int</li>
        <li class="incremental">x == y &nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;hash(x) == hash(y)</li>
        <li class="incremental">hash(x) &nbsp;&nbsp;&nbsp;&#8801;&nbsp;&nbsp;&nbsp; x.__hash__()</li>
    </ul></li>
    <li class="incremental">Dicts use the hash to bucket keys together</li>
    <li class="incremental">(Not cryptographic: SHA1, etc)</li>
    </ul>
</div>

<div class="slide">
    <h1>Fuzzy equality</h1>
    <pre class="python">
    class Pt(namedtuple("Pt", "x, y")):

        def __eq__(self, other):
            x1, y1 = self
            x2, y2 = other
            return (
                math.isclose(x1, x2) and
                math.isclose(y1, y2)
            )
    </pre>
    <pre class="python incremental">
        def __hash__(self):
            #  ¯\_(ツ)_/¯
    </pre>
</div>

<div class="slide">
    <h1>Linear search</h1>
    <pre class="python">
    zz_by_ends = [
        (Pt(10, 20),  [..zigzags..] ),
        (Pt(20, 25),  [..zigzags..] ),
        (Pt(23, 21),  [..zigzags..] ),
    ]
    </pre>
    <pre class="python incremental">
    def find_zigzags(p):
        for pt, zigzags in zz_by_ends:
            if p == pt:     # fuzzy!
                return zigzags
    </pre>
</div>

<div class="slide">
    <h1>Dict-like</h1>
    <pre class="python">
    class PointDict:
        def __init__(self):
            # A list of (pt, value) tuples.
            self.items = []

        # pd[pt]  &#8801;  pd.__getitem__(pt)
        def __getitem__(self, pt):
            for key, value in self.items:
                if key == pt:           # fuzzy!
                    return value

            # Didn't find it: make a new list value and add
            # it to the end.
            value = []
            self.items.append((pt, value))
            return value
    </pre>
</div>

<div class="slide">
    <h1>Advice: abstraction</h1>
    <ul>
    <li class="incremental">Aren't sure of the answer?</li>
    <li class="incremental">Get the question right</li>
    <li class="incremental">Hide uncertainty in an abstraction</li>
    </ul>
    <pre class="python incremental">
    pd = PointDict()
    pd[pt1].append(zz1)
    print(pd[pt1])
    </pre>
</div>

<div class="slide image" data-layout="clean">
    <img src="three_stars_007_joined.png" class="fullwidth"/>
    <div class="incremental popup" style="top:2em;left:4em;">
        It works!
    </div>
    <div class="incremental popup" style="top:4em;right:2em;">
        but it's slow...
    </div>
    <img src='mad_kid.png' class='incremental' style='position:absolute;left:-1px;bottom:-1px;height:70%'/>
</div>


<div class="slide section" data-layout="clean">
    <h1><label>Technique</label> Algorithmic Complexity</h1>
</div>

<div class="slide">
    <h1>Huh?</h1>
    <ul>
    <li class="incremental">Big-O notation</li>
    <li class="incremental">How code slows as data grows</li>
    <li class="incremental">Rough characterization</li>
    </ul>
</div>

<div class="slide">
    <h1>Figuring out big-O</h1>
    <ul>
    <li class="incremental">Analyze the code</li>
    <li class="incremental">How many steps for N items of data?</li>
    <li class="incremental">Only the biggest component</li>
    <li class="incremental">Ignore constants</li>
    </ul>
</div>


<div class="slide">
    <h1>Linear search: O(N)</h1>
    <pre class="python">
    def __getitem__(self, pt):
        for key, value in self.items:       # N/2 + N/2
            if key == pt:                   # N/2
                return value                # 1
    </pre>
    <ul>
    <li class="incremental">Time is proportional to data</li>
    <li class="incremental">Expect N/2 loop iterations
    <li class="incremental">Expected steps are 3*N/2 + 1</li>
    <li class="incremental">Keep the fastest growing, ignore constants: N</li>
    <li class="incremental">O(N)</li>
    </ul>
</div>

<div class="slide">
    <h1>Ideal: O(1)</h1>
    <ul>
    <li class="incremental">Same time no matter how much data!</li>
    <li class="incremental"><tt>mydict[key]</tt> is O(1)</li>
    <li class="incremental">Hashing is the magic</li>
    </ul>
</div>

<div class="slide">
    <h1>The real problem: O(N²)</h1>
    <pre class="python">
    pd = PointDict()    # Actually, slow linear search!
    for zz in all_zigzags:
        others = pd[zz[0]]
    </pre>
    <ul>
    <li class="incremental">PointDict[pt] is O(N)</li>
    <li class="incremental">but called N times</li>
    <li class="incremental">O(N²)</li>
    <li class="incremental">oh noes!</li>
    </ul>
</div>

<div class="slide image" data-layout="clean">
    <img src='graph_complexity.png' class='fullwidth'/>
    <!--
    https://graphsketch.com/?eqn1_color=2&eqn1_eqn=x*x&eqn2_color=4&eqn2_eqn=2*x*log(x)&eqn3_color=1&eqn3_eqn=x&eqn4_color=6&eqn4_eqn=7*log(x)&eqn5_color=3&eqn5_eqn=2&eqn6_color=6&eqn6_eqn=&x_min=0&x_max=30&y_min=0&y_max=40&x_tick=100&y_tick=100&x_label_freq=50&y_label_freq=50&do_grid=0&bold_labeled_lines=0&line_width=4&image_w=850&image_h=650
    -->
</div>

<div class="slide">
    <h1>Python time complexities</h1>
    <table style="float:left;margin-right: 2em">
        <tr><th colspan='2'>Lists</td></tr>
        <tr><td><tt>mylist.append(val)  </tt></td><td>O(1)</td></tr>
        <tr><td><tt>mylist[i]           </tt></td><td>O(1)</td></tr>
        <tr><td><tt>val in mylist       </tt></td><td>O(N)</td></tr>
        <tr><td><tt>for val in mylist:  </tt></td><td>O(N)</td></tr>
    </table>
    <table style="float:left">
        <tr><th colspan='2'>Dicts</td></tr>
        <tr><td><tt>mydict[key] = val   </tt></td><td>O(1)</td></tr>
        <tr><td><tt>mydict[key]         </tt></td><td>O(1)</td></tr>
        <tr><td><tt>key in mydict       </tt></td><td>O(1)</td></tr>
        <tr><td><tt>for key in mydict:  </tt></td><td>O(N)</td></tr>
    </table>
</div>

<div class="slide">
    <h1>Be reasonable</h1>
    <img class="incremental" style="float:left;width:50%" src="fancy-algorithms.png" />
    <div style="float:right;width:40%">
    <ul>
    <li class="incremental">10-element list?
    <li class="incremental">.. Just do it</li>
    <li class="incremental">100? 1000?
    <li class="incremental">.. O(n) probably OK</li>
    </ul>
    </div>
    <img class="incremental" src="graph_complexity_zoom.png" style="position:absolute;right:1em;bottom:3em;width:40%"/>
    <!--
    https://graphsketch.com/?eqn1_color=2&eqn1_eqn=x*x&eqn2_color=4&eqn2_eqn=2*x*log(x%2B1)&eqn3_color=1&eqn3_eqn=x&eqn4_color=6&eqn4_eqn=7*log(x%2B1)&eqn5_color=3&eqn5_eqn=2&eqn6_color=6&eqn6_eqn=&x_min=0&x_max=2&y_min=0&y_max=2.6666&x_tick=100&y_tick=100&x_label_freq=50&y_label_freq=50&do_grid=0&bold_labeled_lines=0&line_width=9&image_w=850&image_h=650
    -->
</div>


<div class="slide section" data-layout="clean">
    <h1><label>Solution</label> Faster Point Matching</h1>
</div>

<div class="slide">
    <h1>Next idea: rounding</h1>
    <pre class="python">
    class Pt(namedtuple("Pt", "x, y")):

        def rounded(self):
            return (round(self.x), round(self.y))

        def __eq__(self, other):
            return self.rounded() == other.rounded()

        def __hash__(self):
            return hash(self.rounded())
    </pre>
    <pre class="python incremental">
    # BUT!
    >>> Pt(11.4999999, 0) == Pt(11.5000001, 0)
    False
    # Because (11.0, 0) != (12.0, 0)
    </pre>
</div>

<div class="slide">
    <h1>Round two ways!</h1>
    <pre class="python">
    def rounded(pt, jitter):
        return round(pt.x + jitter), round(pt.y + jitter)

    def pt_equal(p1, p2):
        return (
            rounded(p1, 0) == rounded(p2, 0) or
            rounded(p1, 0.5) == rounded(p2, 0.5)
        )
    </pre>
    <pre class="python incremental">
    >>> pt_equal(Pt(10.9999999, 0), Pt(11.0000001, 0))
    True
    >>> pt_equal(Pt(11.4999999, 0), Pt(11.5000001, 0))
    True
    </pre>
</div>

<div class="slide">
    <pre class="python medium">
    class PointDict:
        """Like defaultdict(list), with fuzzy Pt's as keys."""
        def __init__(self):
            self.items = {}     # pt -> value
            self.rounds = {}    # pt -> pt

        def __getitem__(self, pt):      <span class="incremental"># O(1)</span>
            val = self.items.get(pt)
            if val is not None:
                return val

            for jitter in [0, 0.5]:
                pt_rnd = rounded(pt, jitter)
                pt0 = self.rounds.get(pt_rnd)
                if pt0 is not None:
                    return self.items[pt0]

            # Not found: make an empty list value
            self.items[pt] = val = []
            for jitter in [0, 0.5]:
                pt_rnd = rounded(pt, jitter)
                self.rounds[pt_rnd] = pt

            return val
    </pre>
</div>

<div class="slide" data-layout="clean">
    <img style="float:right;border: 1px solid #888;width:75%" src="straps.png" />
    <h1>Results</h1>
    <p class="incremental">~2100 points</p>
    <p class="incremental">slow: <b>20</b> sec</p>
    <p class="incremental">fast: <b>0.4</b> sec!</p>
    <img src='happy_kid.png' class='incremental' style='position:absolute;right:-1px;bottom:-1px;height:70%'/>
</div>

<div class="slide">
    <!-- Slow/Fast {{{ -->
    <div style="float: left; width=50%;">
        <h1 style="margin-top: 0">Slow</h1>
        <div style="position: relative; width=100%">
            <pre class="python small" style="margin-top:0">
                def __init__(self):
                    self.items = []

                def __getitem__(self, pt):
                    for key, value in self.items:
                        if key == pt:
                            return value

                    value = []
                    self.items.append((pt, value))
                    return value
            </pre>
            <div class="incremental" style="margin-top:6em; width:3em;">
                <p class="o_1">&nbsp;&nbsp;O(1)</p>
                <p class="o_n">&nbsp;&nbsp;O(n)</p>
            </div>
            <pre class="python small incremental" style="position: absolute; top:0; left:0; margin-top:0">
                def __init__(self):
                    self.items = []

                def __getitem__(self, pt):
                    <span class="o_n">for key, value in self.items:</span>
                        if key == pt:
                            return value

                    value = []
                    <span class="o_1">self.items.append((pt, value))</span>
                    return value
            </pre>
        </div>
    </div>
    <div style="position: absolute; top:0; right:0;width=50%">
        <h1 style="margin-top: 0">Fast</h1>
        <div style="position: relative; width=100%; padding-right: 2em">
            <pre class="python small" style="margin-top:0">
                def __init__(self):
                    self.items = {}     # pt -> value
                    self.rounds = {}    # pt -> pt

                def __getitem__(self, pt):
                    val = self.items.get(pt)
                    if val is not None:
                        return val

                    for jitter in [0, 0.5]:
                        pt_rnd = rounded(pt, jitter)
                        pt0 = self.rounds.get(pt_rnd)
                        if pt0 is not None:
                            return self.items[pt0]

                    self.items[pt] = val = []
                    for jitter in [0, 0.5]:
                        pt_rnd = rounded(pt, jitter)
                        self.rounds[pt_rnd] = pt

                    return val
            </pre>
            <pre class="python small incremental" style="position: absolute; top:0; left:0; margin-top:0">
                def __init__(self):
                    self.items = {}     # pt -> value
                    self.rounds = {}    # pt -> pt

                def __getitem__(self, pt):
                    val = <span class="o_1">self.items.get(pt)</span>
                    if val is not None:
                        return val

                    for jitter in [0, 0.5]:
                        pt_rnd = rounded(pt, jitter)
                        pt0 = <span class="o_1">self.rounds.get(pt_rnd)</span>
                        if pt0 is not None:
                            return <span class="o_1">self.items[pt0]</span>

                    <span class="o_1">self.items[pt] = val = []</span>
                    for jitter in [0, 0.5]:
                        pt_rnd = rounded(pt, jitter)
                        <span class="o_1">self.rounds[pt_rnd] = pt</span>

                    return val
            </pre>
        </div>
    </div>
    <!-- }}} -->
</div>

<div class="slide">
    <h1>Algorithms!</h1>
    <ul>
    <li>Understand your data structures</li>
    <li>Speed comes from better algorithms</li>
    </ul>
</div>

<div class="slide section" data-layout="clean">
    <h1><label>Advice</label> Better Abstraction</h1>
</div>

<div class="slide">
    <h1>One Thing</h1>
    <ul>
    <li class="incremental">"Classes (or functions) should do one thing"</li>
    <li class="incremental">But: what is "one thing"?</li>
    <li class="incremental">Does PointDict do one thing?
        <ul>
            <li class="incremental">Yes: look up values by fuzzy points</li>
            <li class="incremental">No:
                <ol>
                    <li>Defuzz points</li>
                    <li>Look up values</li>
                </ol>
            </li>
        </ul>
    </li>
    </ul>
    <img class="incremental" src="noidea4.jpg" style="width:45%;position:absolute;bottom:2em;right:1em"/>
</div>

<div class="slide">
    <h1>Doing less</h1>
    <pre class="python">
    class Defuzzer:
        def defuzz(self, pt):
            """Return pt, or a previous equal point."""
    </pre>
    <pre class="python incremental">
    >>> defuzz = Defuzzer().defuzz
    >>> defuzz(Pt(1, 2))
    Pt(1, 2)
    >>> defuzz(Pt(3, 4))
    Pt(3, 4)
    >>> defuzz(Pt(1.01, 2))
    Pt(1, 2)
    </pre>
</div>

<div class="slide">
    <pre class="python">
    def defuzz_path(path):
        return [defuzz(pt) for pt in path]

    def defuzz_paths(paths):
        return [defuzz_path(path) for path in paths]
    </pre>
    <pre class="python incremental">
    def combine_paths(paths):
        paths = defuzz_paths(paths)
        paths_by_ends = defaultdict(list)
        for path in paths:
            paths_by_ends[path[0]].append(path)
            paths_by_ends[path[-1]].append(path)

        for path in paths:
            others = paths_by_ends[path[0]]
            etc()
    </pre>
</div>

<div class="slide">
    <h1>Tip: Be flexible</h1>
    <ul>
    <li class="incremental">Things change</li>
    <li class="incremental">Change with them</li>
    <li class="incremental">Be ready to change your mind</li>
    <li class="incremental">Plan, but discover as you go</li>
    </ul>
</div>


<div class="slide section" data-layout="clean">
    <h1><label>Challenge</label> Representation</h1>
</div>

<div class="slide">
    <h1>Paths</h1>
    <ul>
        <li>A path is just a list of points
        <pre class="python medium">
        path = [Pt(0, 0), Pt(1, 1), Pt(10, 0)]
        </pre>
        </li>
        <li class="incremental">Lots of functions:
        <pre class="python medium">
        def path_length(path): ...

        def canonicalize_path(path): ...

        def offset_path(path, offset): ...
        </pre>
        </li>
    </ul>
</div>

<div class="slide">
    <h1>Classes</h1>
    <ul>
    <li class="incremental">Formalizes data + code for data</li>
    </ul>
    <pre class="python incremental">
    class Path:
        def __init__(self, points):
            self.points = points

        def length(self): ...

        def canonicalize(self): ...

        def offset(self, offset): ...
    </pre>
    <ul>
        <li class="incremental">Nicer names</li>
        <li class="incremental">Fewer imports</li>
    </ul>
</div>


<div class="slide">
    <h1>Open/closed paths</h1>
    <ul>
        <li class="incremental">Old way, scattered around:
        <pre class="python medium">
        if path[0] == path[-1]:
        </pre>
        </li>
    </ul>
    <ul>
        <li class="incremental">New way:
        <pre class="python medium">
        class Path:
            ...
            @property
            def closed(self):
                return self.points[0] == self.points[-1]
        </pre>
        <pre class="python medium">
        if path.closed:
        </pre>
        </li>
    </ul>
</div>

<div class="slide">
    <h1>Collection of Paths</h1>
    <ul>
    <li class="incremental">Just a list of Path</li>
    </ul>
    <pre class="python incremental">
    def paths_length(paths):
        return sum(p.length() for p in paths)

    def defuzz_paths(paths):
        return [p.defuzz() for p in paths]
    </pre>
    <img class="incremental" src="noidea2.jpg"
        style="width:45%;position:absolute;bottom:3em;right:3em"/>
</div>

<div class="slide">
    <h1>Evolution</h1>
    <ul>
    <li class="incremental">Value</li>
    <li class="incremental" style="padding-left:2em">Tuple</li>
    <li class="incremental" style="padding-left:4em">Dict</li>
    <li class="incremental" style="padding-left:6em">Class</li>
    <li class="incremental">Be ready and flexible</li>
    </ul>
</div>

<div class="slide">
    <h1>namedtuple</h1>
    <!--[[[cog
    from cogutil import prompt_session
    prompt_session("""\
        from collections import namedtuple
        Pt = namedtuple("Pt", "x, y")   # Like "class Pt:"
        p = Pt(10, 20)
        p
        p.x
        x, y = p                # Unpacking the tuple
        x
        """)
    ]]]-->
    <pre class='python pycon'>

    &gt;&gt;&gt; from collections import namedtuple
    &gt;&gt;&gt; Pt = namedtuple("Pt", "x, y")   # Like "class Pt:"
    &gt;&gt;&gt; p = Pt(10, 20)
    &gt;&gt;&gt; p
    Pt(x=10, y=20)
    &gt;&gt;&gt; p.x
    10
    &gt;&gt;&gt; x, y = p                # Unpacking the tuple
    &gt;&gt;&gt; x
    10


    </pre>
    <!--[[[end]]] -->
    <!--[[[cog
    prompt_session("""\
        p.x = 17
        """,
        prelude="""
        from collections import namedtuple
        Pt = namedtuple("Pt", "x, y")   # Like: class Pt:
        p = Pt(10, 20)
        """)
    ]]]-->
    <pre class='python pycon'>

    &gt;&gt;&gt; p.x = 17
    Traceback (most recent call last):
      File "&lt;console&gt;", line 1, in &lt;module&gt;
    AttributeError: can't set attribute


    </pre>
    <!--[[[end]]] -->
</div>

<div class="slide">
    <h1>Problems with namedtuple</h1>
    <ul>
    <li class="incremental">Not really types</li>
    <li class="incremental">Inflexible</li>
    <li class="incremental">Weren't meant for this</li>
    </ul>
</div>

<div class="slide">
    <h1>attrs</h1>
    <ul>
    <li class="incremental">3rd-party lib</li>
    <li class="incremental">Simple classes with less boilerplate</li>
    </ul>
    <!--[[[cog
    prompt_session("""\
        import attr
        @attr.s
        class Pt(object):
            x = attr.ib()
            y = attr.ib()

        p = Pt(10, 20)
        p
        """, klass="incremental")
    ]]]-->
    <pre class='python pycon incremental'>

    &gt;&gt;&gt; import attr
    &gt;&gt;&gt; @attr.s
    ... class Pt(object):
    ...     x = attr.ib()
    ...     y = attr.ib()
    ... 
    &gt;&gt;&gt; p = Pt(10, 20)
    &gt;&gt;&gt; p
    Pt(x=10, y=20)


    </pre>
    <!--[[[end]]] -->
    <ul>
    <li class="incremental">Plus: defaults, validators, etc</li>
    </ul>
</div>

<div class="slide">
    <h1>Clash of the classes</h1>
    <ul>
    <li>How do classes relate?</li>
    <li class="incremental"><tt>Line(pt1, pt2)</tt></li>
    <li class="incremental"><tt>line1.intersect(line2)</tt></li>
    <li class="incremental"><tt>pt1.distance(pt2)</tt></li>
    <li class="incremental"><tt>collinear(pt1, pt2, pt3)</tt></li>
    <li class="incremental"><tt>drawing.draw(path)</tt> <em>or</em> <tt>path.draw(drawing)</tt> ?</li>
    </ul>
    <img class="incremental" src="noidea3.jpg" style="width:45%;position:absolute;top:0em;right:1em"/>
</div>

<div class="slide">
    <h1>Finding Meaning</h1>
    <ul>
        <li>When do rectangles overlap?</li>
    </ul>
    <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%">
        <g transform="translate(20 40) scale(1.75 1.75)">
        <!--[[[cog
            def cells():
                colwidth = 200
                rowheight = 150
                for r in range(0, 9999, rowheight):
                    for c in range(0, colwidth * 3, colwidth):
                        yield c, r

            rects = [
                # x, y, w, h;  x, y, w, h
                ((0, 0, 100, 50), (25, 25, 100, 50)),
                ((0, 0, 100, 20), (25, 50, 100, 20)),
                #((30, 0, 30, 100), (0, 30, 100, 30)),
                ((20, 0, 30, 100), (50, 25, 50, 50)),
                ((20, 0, 30, 30), (50, 30, 30, 30)),
                ((30, 0, 60, 100), (0, 50, 100, 1)),
                ((0, 30, 60, 1), (60, 30, 1, 40)),
            ]

            for (c, r), (rect1, rect2) in zip(cells(), rects):
                cog.outl('<g class="incremental" transform="translate({} {})">'.format(c, r))
                cog.outl('<rect x="{}" y="{}" width="{}" height="{}" fill="red" fill-opacity="0.5"/>'.format(*rect1))
                cog.outl('<rect x="{}" y="{}" width="{}" height="{}" fill="blue" fill-opacity="0.5"/>'.format(*rect2))
                cog.outl('</g>')
        ]]]-->
        <g class="incremental" transform="translate(0 0)">
        <rect x="0" y="0" width="100" height="50" fill="red" fill-opacity="0.5"/>
        <rect x="25" y="25" width="100" height="50" fill="blue" fill-opacity="0.5"/>
        </g>
        <g class="incremental" transform="translate(200 0)">
        <rect x="0" y="0" width="100" height="20" fill="red" fill-opacity="0.5"/>
        <rect x="25" y="50" width="100" height="20" fill="blue" fill-opacity="0.5"/>
        </g>
        <g class="incremental" transform="translate(400 0)">
        <rect x="20" y="0" width="30" height="100" fill="red" fill-opacity="0.5"/>
        <rect x="50" y="25" width="50" height="50" fill="blue" fill-opacity="0.5"/>
        </g>
        <g class="incremental" transform="translate(0 150)">
        <rect x="20" y="0" width="30" height="30" fill="red" fill-opacity="0.5"/>
        <rect x="50" y="30" width="30" height="30" fill="blue" fill-opacity="0.5"/>
        </g>
        <g class="incremental" transform="translate(200 150)">
        <rect x="30" y="0" width="60" height="100" fill="red" fill-opacity="0.5"/>
        <rect x="0" y="50" width="100" height="1" fill="blue" fill-opacity="0.5"/>
        </g>
        <g class="incremental" transform="translate(400 150)">
        <rect x="0" y="30" width="60" height="1" fill="red" fill-opacity="0.5"/>
        <rect x="60" y="30" width="1" height="40" fill="blue" fill-opacity="0.5"/>
        </g>
        <!--[[[end]]] -->
        </g>
    </svg>
</div>


<div class="slide section" data-layout="clean">
    <h1><label>Challenge?</label> Other People's Code</h1>
</div>

<div class="slide">
    <h1>2D transformations</h1>
    <ul>
    <li class="incremental">Write it myself?</li>
    <li class="incremental">Third-party exists!</li>
    <li class="incremental">Worked great</li>
    <li class="incremental">End of story</li>
    </ul>
</div>


<div class="slide">
    <h1>Line intersections</h1>
    <pre class="python">
    def segment_intersections(segments):
        isects = defaultdict(list)

        for seg1 in segments:
            for seg2 in segments:
                if seg1 is seg2:
                    continue

                isect_pt = seg1.intersect(seg2)
                if isect_pt is not None:
                    isects[isect_pt].extend([seg1, seg2])

        return isects
    </pre>
</div>

<div class="slide" data-layout="clean">
    <h1>Better algorithm</h1>
    <img src='wiki-bentley.png' class='fullwidth'/>
    <img class="incremental popup" src='bentley-zoom.png'
        style='left:1em;top:8em;width:80%'
        />
</div>

<div class="slide image" data-layout="clean">
    <img src='github-ideasman.png' class='fullwidth'/>
</div>

<div class="slide image" data-layout="clean">
    <img src='github-issue.png' class='fullheight'/>
</div>

<div class="slide image" data-layout="clean">
    <img src='github-pr.png' class='fullheight'/>
    <img src='Rainbow-Heart-Glitter.gif' class='incremental'
        style="position:absolute;top:3em;right:1em;width:40%"/>
</div>

<div class="slide">
    <h1>But: ouch!</h1>
    <pre>
  File ".../poly_point_isect.py", line 576, in isect_segments_impl
    sweep_line.handle(p, events_current)
  File ".../poly_point_isect.py", line 384, in handle
    self.handle_event(e)
  File ".../poly_point_isect.py", line 408, in handle_event
    self.remove(event)
 File ".../poly_point_isect.py", line 346, in remove
    assert(event.in_sweep == False)
AssertionError
    </pre>
    <ul>
        <li class="incremental">Sensitive to angle!?</li>
    </ul>
</div>

<div class="slide">
    <h1>The horror!</h1>
    <pre class="python">
    def intersections():
        for angle in [x/6 for x in range(60)]:
            rotate_everything(angle)

            try:
                isects = isect_segments()
            except AssertionError:
                print(f"Failed at rotation {angle}")
                continue

            rotate_everything(-angle)
            return isects
    </pre>
</div>

<div class="slide">
    <h1>¯\_(ツ)_/¯</h1>
    <pre>
Failed at rotation 0.0
Failed at rotation 0.1666666666
Failed at rotation 0.3333333333
Failed at rotation 0.5
Failed at rotation 0.6666666666
Failed at rotation 0.8333333334
Failed at rotation 1.0
Failed at rotation 1.1666666667
1728 intersections
    </pre>
    <img class="incremental" src="didbad1.jpg"
        style="position:absolute;top:0em;right:1em;width:40%"
        />
</div>

<div class="slide">
    <h1>Buy vs Build</h1>
    <ul>
    <li class="incremental">Not literally "buy"</li>
    <li class="incremental">Not easy to decide</li>
    </ul>
</div>


<div class="slide section" data-layout="clean">
    <h1><label>Advice</label> Tooling</h1>
</div>


<div class="slide">
    <h1>Write "libraries"</h1>
    <ul>
    <li class="incremental">More abstraction</li>
    <li class="incremental">Work at a higher level</li>
    </ul>
    <pre class="python incremental">
    def all_pairs(seq):
        """Produce all pairs from seq, but not (a, a)"""
        return itertools.combinations(seq, 2)
    </pre>
    <ul>
    <li class="incremental">But: YAGNI (You Ain't Gonna Need It)</li>
    </ul>
</div>


<div class="slide">
    <h1>Write code to help you debug</h1>
    <ul>
    <li class="incremental">def __repr__(self):</li>
    <li class="incremental">assert</li>
    <li class="incremental">if debug:</li>
    </ul>
</div>

<div class="slide" data-layout="clean">
    <h1>First rule of debugging</h1>
    <ul>
    <li class="incremental">When in Doubt,</li>
    <li class="incremental">Print More Out!</li>
    </ul>
    <img class="incremental" src='debugs_breath.png'
        style="position:absolute;bottom:1em;right:1em;width:60%;"/>
</div>

<div class="slide" data-layout="clean">
    <!-- Debugging, highlighted -->
    <!--[[[cog {{{
        with open("debugging_strap.py") as f:
            lines = textwrap.dedent(f.read()).splitlines()
        hiranges = [
            # "debug"
            (20,21), (30,31), (126,133), (136,136), (144,144), (147,162),
            (166,166), (168,174), (227,246), (258,278),
            # "assert"
            (89,89), (178,178), (187,187), (193,193), (201,201),
        ]
        hilines = set()
        for lo, hi in hiranges:
            hilines.update(range(lo, hi+1))
        lines = [quote_html(l[:88]) for l in lines]
        chunk = 100
        result = []
        for start in range(0, len(lines), chunk):
            these_lines = lines[start:start+chunk]
            if these_lines[0][0] == ' ':
                these_lines[0] = '&nbsp;' + these_lines[0][1:]
            style = 'font-size: 21%; width:48em; margin-right: 2em; float: left'
            result.append("<pre class='python' style='{style}'>".format(style=style))
            for lineno, line in enumerate(these_lines, start=start+1):
                if lineno in hilines:
                    line = "<span class='highlight'>" + line + "</span>"
                result.append(line)
            result.append("</pre>")
        cog.outl("\n".join(result))
    ]]] -->
    <pre class='python' style='font-size: 21%; width:48em; margin-right: 2em; float: left'>
    """Strappiness for Zellij."""

    import collections
    import itertools
    import random

    from zellij.debug import should_debug
    from zellij.drawing import Drawing, DrawingSequence
    from zellij.euclid import Point, Segment
    from zellij.intersection import segment_intersections
    from zellij.path_tiler import join_paths, offset_path, path_segments, trim_path


    class Xing:
        def __init__(self, under=None, over=None):
            self.under = under
            self.over = over
            self.over_piece = None

    <span class='highlight'>    def __repr__(self):</span>
    <span class='highlight'>        return f"&lt;Xing under={show_path(self.under)} over={show_path(self.over)}&gt;"</span>

    class Strap:
        def __init__(self, path, width, random_factor=0):
            self.path = path
            if random_factor:
                width *= (1 + random.random() * random_factor)
            self.sides = [offset_path(path, d) for d in [width/2, -width/2]]

    <span class='highlight'>    def __repr__(self):</span>
    <span class='highlight'>        return f"&lt;Strap path={self.path}&gt;"</span>


    def path_pieces(path, segs_to_points):
        """Produce a new series of paths, split at intersection points.

        Yields a series of pieces (paths).  The pieces trace the same line as the
        original path.  The endpoints of the pieces are all intersection points
        in `segs_to_points`, or the endpoints of the original path, if it isn't
        circular.  The pieces are in order along `path`, so consecutive pieces
        end and begin at the same point. If `path` is closed, then the first piece
        returned will begin at the first cut, not at the path's first point.

        """
        # If path is circular, then the first piece we collect has to be added to
        # the last piece, so save it for later.
        collecting_head = (path[0] == path[-1])
        head = None

        piece = []
        for pt in path:
            if not piece:
                piece.append(pt)
            else:
                seg = Segment(piece[-1], pt)
                cuts = segs_to_points.get(seg)
                if cuts is not None:
                    cuts = seg.sort_along(cuts)
                    for cut in cuts:
                        ptcut = Point(*cut)
                        piece.append(ptcut)
                        if collecting_head:
                            head = piece
                            collecting_head = False
                        else:
                            yield piece
                        piece = [ptcut]
                piece.append(pt)

        if head:
            piece = join_paths(piece, head)
        yield piece


    def pieces_under_over(path, segs_to_points, xings):
        """Produce all the pieces of the path, with a bool indicating if each leads to under
        pieces = list(path_pieces(path, segs_to_points))
        for i, piece in enumerate(pieces):
            xing = xings.get(piece[-1])
            if xing is None:
                continue
            if xing.under == path:
                over = False
            elif xing.over == path:
                over = True
            elif xing.under is not None:
                over = True
            else:
    <span class='highlight'>            assert xing.over is not None</span>
                over = False
            ou = [over, not over]
            if i % 2:
                ou = ou[::-1]
            break
        else:
            ou = [True, False]

        yield from zip(pieces, itertools.cycle(ou))


    </pre>
    <pre class='python' style='font-size: 21%; width:48em; margin-right: 2em; float: left'>
    def strapify(paths, **strap_kwargs):
        """Turn paths intro straps."""

        paths = [tuple(path) for path in paths]

        segments = []
        segs_to_paths = {}
        for path in paths:
            for segment in path_segments(path):
                segments.append(segment)
                segs_to_paths[segment] = path

        points_to_segments = segment_intersections(segments)
        isect_points = list(points_to_segments.keys())

        segs_to_points = collections.defaultdict(list)
        for pt, segs in points_to_segments.items():
            for seg in segs:
                segs_to_points[seg].append(pt)

        points_to_paths = collections.defaultdict(list)
        for isect, segs in points_to_segments.items():
            for seg in segs:
                points_to_paths[isect].append(segs_to_paths[seg])

    <span class='highlight'>    print(f"{len(isect_points)} intersections")</span>
    <span class='highlight'></span>
    <span class='highlight'>    if 0:</span>
    <span class='highlight'>        debug_output(dwgw=DWGW, paths=paths, segments=segments, isects=isect_points)</span>
    <span class='highlight'></span>
    <span class='highlight'>    debug = should_debug("strapify")</span>
    <span class='highlight'>    if debug:</span>
    <span class='highlight'>        dbgdwgs = iter(DrawingSequence(name="debugs_", paths=paths))</span>

        paths_to_do = set(paths)
    <span class='highlight'>    paths_done = set()</span>
        xings = {}      # pt -&gt; xing
        straps = []     # new smaller paths, ending at unders.
        path = None
        while paths_to_do:
            next_paths = set()
            next_paths.add(paths_to_do.pop())
            while next_paths:
    <span class='highlight'>            previous_path = path</span>
                path = next_paths.pop()

    <span class='highlight'>            if debug:</span>
    <span class='highlight'>                dwg = next(dbgdwgs)</span>
    <span class='highlight'>                dwg.draw_segments(segments, rgb=(0, 0, 0), width=1)</span>
    <span class='highlight'>                dwg.draw_paths(paths_done, rgb=(0, 0, 0), width=3)</span>
    <span class='highlight'>                dwg.draw_paths(next_paths, rgb=(.7, .7, 0), width=9)</span>
    <span class='highlight'>                if previous_path:</span>
    <span class='highlight'>                    dwg.draw_path(previous_path, rgb=(1, 0, 0), width=10, dash=[30, 30])</span>
    <span class='highlight'>                dwg.draw_path(path, rgb=(1, 0, 0), width=15)</span>
    <span class='highlight'>                dwg.fill_points([path[0]], rgb=(1, 0, 0), radius=15*3/2)</span>
    <span class='highlight'>                dwg.fill_points([path[1]], rgb=(1, 0, 0), radius=15*2/2)</span>
    <span class='highlight'>                partial_over = [pt for pt, xing in xings.items() if xing.under is None]</span>
    <span class='highlight'>                partial_under = [pt for pt, xing in xings.items() if xing.over is None]</span>
    <span class='highlight'>                dwg.circle_points(partial_over, rgb=(.8, 0, 0), radius=21, width=9)</span>
    <span class='highlight'>                dwg.circle_points(partial_under, rgb=(0, 0, .8), radius=21, width=9)</span>
    <span class='highlight'>                done = [pt for pt, xing in xings.items() if xing.under is not None and x</span>
    <span class='highlight'>                dwg.circle_points(done, rgb=(0, .8, 0), radius=15, width=3)</span>

                prev_piece = None
                last_cut = None
    <span class='highlight'>            first_piece = True</span>
                for piece, over in pieces_under_over(path, segs_to_points, xings):
    <span class='highlight'>                if first_piece and debug:</span>
    <span class='highlight'>                    dwg.cross_points([piece[0], piece[-1]], radius=20, rgb=(1, 0, 0), wi</span>
    <span class='highlight'>                    dwg.finish()</span>
    <span class='highlight'>                    if 0 and dwg.num &gt; 10:</span>
    <span class='highlight'>                        print()</span>
    <span class='highlight'>                        import sys; sys.exit()</span>
    <span class='highlight'>                    first_piece = False</span>

                    cut = None
                    if over:
    <span class='highlight'>                    assert prev_piece is None</span>
                        prev_piece = piece
                        if last_cut:
                            cut = last_cut
                            xing = xings.get(cut)
                            if xing is None:
                                xing = Xing(under=path)
                                xings[cut] = xing
                            else:
    <span class='highlight'>                            assert xing.under is None or xing.under == path</span>
                                xing.under = path
                            last_cut = None
                    else:
                        if prev_piece:
                            cut = prev_piece[-1]
    <span class='highlight'>                        assert cut == piece[0]</span>
                            strap = Strap(join_paths(prev_piece, piece), **strap_kwargs)
                            straps.append(strap)
                            xing = xings.get(cut)
                            if xing is None:
                                xing = Xing(over=path)
                                xings[cut] = xing
                            else:
    </pre>
    <pre class='python' style='font-size: 21%; width:48em; margin-right: 2em; float: left'>
    <span class='highlight'>&nbsp;                           assert xing.over is None or xing.over == path</span>
                                xing.over = path
                            xing.over_piece = strap
                        else:
                            straps.append(Strap(piece, **strap_kwargs))
                        last_cut = piece[-1]
                        prev_piece = None
                    if cut:
                        for next_path in points_to_paths[cut]:
                            if next_path in paths_to_do:
                                paths_to_do.remove(next_path)
                                next_paths.add(next_path)
                if prev_piece:
                    strap = Strap(prev_piece, **strap_kwargs)
                    straps.append(strap)
                    closed = (path[0] == path[-1])
                    if closed:
                        cut = prev_piece[-1]
                        xing = xings.get(cut)
                        if xing is None:
                            xing = Xing(over=path)
                            xings[cut] = xing
                        else:
                            xing.over = path
                        xing.over_piece = strap

    <span class='highlight'>            paths_done.add(path)</span>
    <span class='highlight'>            if debug:</span>
    <span class='highlight'>                dwg.cross_points([piece[0], piece[-1]], radius=30, rotate=30, rgb=(0, 0,</span>
    <span class='highlight'>                dwg.finish()</span>
    <span class='highlight'>                if 0 and dwg.num &gt; 10:</span>
    <span class='highlight'>                    print()</span>
    <span class='highlight'>                    import sys; sys.exit()</span>
    <span class='highlight'></span>
    <span class='highlight'>    if 0:</span>
    <span class='highlight'>        bad = [pt for pt, xing in xings.items() if xing.over_piece is None]</span>
    <span class='highlight'>        debug_output(dwgw=DWGW, paths=paths, segments=segments, isects=bad)</span>
    <span class='highlight'></span>
    <span class='highlight'>    if debug:</span>
    <span class='highlight'>        for strap in straps:</span>
    <span class='highlight'>            dwg = next(dbgdwgs)</span>
    <span class='highlight'>            dwg.draw_segments(segments, rgb=(0, 0, 0), width=1)</span>
    <span class='highlight'>            dwg.draw_path(strap.path, rgb=(1, 0, 0), width=3)</span>
    <span class='highlight'>            for s in strap.sides:</span>
    <span class='highlight'>                dwg.draw_path(s, rgb=(0, 0, 1), width=1)</span>
    <span class='highlight'>            dwg.finish()</span>

        for strap in straps:
            for end in [0, -1]:
                xing = xings.get(strap.path[end])
                if xing is not None:
                    trimmers = xing.over_piece.sides
                    strap.sides = [trim_path(s, end, trimmers) for s in strap.sides]

        return straps


    <span class='highlight'>def debug_output(dwgw=None, paths=None, segments=None, isects=None):</span>
    <span class='highlight'>    dwg = Drawing(paths=paths, name="debug.png")</span>
    <span class='highlight'>    dwg.draw_segments(segments, rgb=(0, 0, 0), width=1)</span>
    <span class='highlight'></span>
    <span class='highlight'>    dup_segments = []</span>
    <span class='highlight'>    segments.sort()</span>
    <span class='highlight'>    for s1, s2 in zip(segments, segments[1:]):</span>
    <span class='highlight'>        if s1 == s2:</span>
    <span class='highlight'>            dup_segments.append(s1)</span>
    <span class='highlight'></span>
    <span class='highlight'>    dwg.draw_segments(dup_segments, rgb=(1, 0, 0), width=7)</span>
    <span class='highlight'></span>
    <span class='highlight'>    if dwgw is not None:</span>
    <span class='highlight'>        with dwg.style(rgb=(0, 0, 1), width=2, dash=[5, 5]):</span>
    <span class='highlight'>            dwg.rectangle(0, 0, dwgw, dwgw)</span>
    <span class='highlight'>            dwg.stroke()</span>
    <span class='highlight'></span>
    <span class='highlight'>    if isects is not None:</span>
    <span class='highlight'>        dwg.circle_points(isects, radius=9, rgb=(0, .5, 0), width=3)</span>
    <span class='highlight'></span>
    <span class='highlight'>    dwg.finish()</span>
    </pre>
    <!--[[[end]]] }}}-->
</div>

<div class="slide section" data-layout="clean">
    <h1>Wrapping Up</h1>
</div>

<div class="slide">
    <h1>Advice</h1>
    <ul>
    <li class="incremental">Write abstractions</li>
    <li class="incremental">Be flexible</li>
    <li class="incremental">Watch your algorithms</li>
    <li class="incremental">Build useful tooling</li>
    <li class="incremental">Don't be hard on yourself</li>
    <li class="incremental">Have fun!</li>
    </ul>
</div>

<div class="slide title" data-layout="clean">
    <h1 style="margin-top:0;padding-top:0">The End</h1>
    <img src='card_straps.png' class='fullwidth' style='border: 1px solid #888'/>
</div>

<div class="slide image" data-layout="clean">
    <img src='debug_world.png' class='fullwidth'/>
</div>



<!-- ** Layouts {{{ -->
<div class="layout" data-name="default">
    <content></content>
    <div class="footer">
        <span class="left">bit.ly<span class='punct'>/</span>bospyvaca</span>
        <span class="right"><span class='punct'>@</span>nedbat</span>
        <hr class="defloat" />
    </div>
</div>

<div class="layout nofooter" data-name="clean">
    <content></content>
</div>

<!-- }}} -->

</body>
</html>
