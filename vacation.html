<!DOCTYPE html> <!-- vim: set foldmethod=marker cc=60 :-->
<!--

Process this file with cog:

    $ pip install -r requirements.txt
    $ python -m cogapp -r blank.html

-->
<html>
<!-- *** Head stuff {{{ -->
<!--[[[cog
import cog
from cogutil import *
]]]-->
<!--[[[end]]]-->
<head>
<title>What I Did on my Summer Vacation</title>
<meta charset="utf-8" />

    <!-- *** Includes {{{ -->
    <!-- Slippy core file and dependencies -->
    <script type="text/javascript" src="slippy/jquery.min.js"></script>
    <script type="text/javascript" src="slippy/jquery.history.js"></script>
    <script type="text/javascript" src="slippy/slippy.js"></script>
    <!-- Slippy structural styles -->
    <link type="text/css" rel="stylesheet" href="slippy/slippy.css"/>
    <!-- Slippy theme -->
    <link type="text/css" rel="stylesheet" href="slippy/slippy-pure.css"/>
    <!-- Our styles -->
    <link type="text/css" rel="stylesheet" href="slides.css"/>

    <!-- Highlight, for syntax coloring. -->
    <script type="text/javascript" src="highlight/highlight.pack.js"></script>
    <link rel="stylesheet" href="highlight/vs.css">

    <script type="text/javascript" src="lineselect.js"></script>

    <!-- http://html.adobe.com/edge/webfonts/ -->
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800' rel='stylesheet' type='text/css'>
    <!-- }}} -->

    <!-- *** Init code {{{ -->
    <script type="text/javascript">
        $(function() {
            if ($("body.slides").length) {
                // Visit vacation.html?showall to see all the incremental stuff at once...
                var showall = (window.location.href.indexOf("showall") !== -1);
                $(".slide").slippy({
                    // settings go here
                    // possible values are:
                    //  - animLen, duration for default animations (0 = disabled)
                    //  - animInForward, receives a slide and animates it
                    //  - animInRewind, receives a slide and animates it
                    //  - animOutForward, receives a slide and animates it
                    //  - animOutRewind, receives a slide and animates it
                    //  - baseWidth, defines the base for img resizing, if you don't want only
                    //    full-width images, specify this as the pixel width of a slide so that
                    //    images are scaled properly (default is 620px wide)
                    //  - ratio, defines the width/height ratio of the slides, defaults to 1.3 (620x476)
                    //  - margin, the fraction of screen to use as slide margin, defaults to 0.15
                    margin: 0.01,
                    incrementalBefore: function (el) {
                        if (!showall) {
                            $(el).css({ opacity: 0.01 });
                        }
                    },
                    animInForward: function (slide) {
                        var slide = $(slide);
                        if (slide.hasClass("fadein")) {
                            slide.css('opacity', '0').css('left', '50%').animate({opacity: '1'}, 650);
                        }
                        else {
                            slide.css('left', '150%').animate({left: '50%'}, 350);
                        }
                        if (!showall) {
                            slide.find(".incremental").css({opacity:0});    // IDK why this hides them, but 0.01 does not.
                        }
                    },
                    animOutForward: function(slide) {
                        var slide = $(slide);
                        if (slide.hasClass("fadeout")) {
                            slide.animate({opacity: '1'}, 650).animate({left: '-50%'}, 0);
                        }
                        else {
                            slide.animate({left: '-50%'}, 350);
                        }
                    }
                });
            }

            // Highlight the code in <pre> blocks.
            $('pre').each(function (i, e) {
                hljs.highlightBlock(e, '    ');
            });

            // Convert <pre> to have <span class='line'> for each line.
            $('pre').each(function (i, e) {
                var $e = $(e);
                var lines = $e.html().split("\n");
                for (var i = 0; i < lines.length; i++) {
                    var line = lines[i];
                    if (line === "") {
                        lines[i] = "<span class='blankline'>&nbsp;</span>";
                    }
                    else {
                        lines[i] = "<span class='line'>" + lines[i] + "</span>";
                    }
                }
                $e.html(lines.join("\n"));
            });

            $("div.slide").lineselect({ lines: "pre span.line" });

            // Pre-select lines based on a select= attribute.
            $('pre').each(function (i, e) {
                var $e = $(e);
                var select = $e.attr("select");
                if (select) {
                    $e.lineselect(select);
                }
            });
        });
    </script>
    <!-- }}} -->

    <!-- *** Custom style for this deck {{{ -->
    <style type="text/css">
    .slide.image {
        text-align: center;
    }
    .o_1 {
        background: #3f3;
        border-radius: .15em;
    }
    .o_n {
        background: #fbb;
        border-radius: .15em;
    }

    </style>
    <!-- }}} -->

</head>
<!-- }}} -->
<body class="slides">

<div class="slide title" data-layout="clean">
    <h1>What I Did on my<br>Summer Vacation</h1>
    <h2>Ned Batchelder<br/><a class="implicit" href="https://twitter.com/nedbat"><span class="punct">@</span>nedbat</a></h2>
    <h2><a class="implicit" href="https://bit.ly/bospyvaca"><span class="punct">https://</span>bit.ly<span class="punct">/</span>bospyvaca</a></h2>
</div>

<div class="text"><!-- {{{ -->

<p>Blah blah blah.</p>

</div><!-- }}} -->

<div class="slide">
    <h1>Big Picture</h1>
    <ul>
    <li class="incremental">Side project</li>
    <li class="incremental">Concepts, techniques, advice</li>
    <li class="incremental">Questions are OK!</li>
    </ul>
</div>

<div class="slide">
    <h1>Software is hard</h1>
    <ul>
    <li class="incremental">No easy answers</li>
    <li class="incremental">Even small projects have tricky questions</li>
    </ul>
</div>

<div class="slide">
    <h1>We're all in this together</h1>
    <img class='incremental' src='noidea1.jpg' />
</div>

<div class="slide image" data-layout="clean">
    <img src='twostates.jpg' />
</div>

<div class="slide section">
    <h1>My Vacation</h1>
</div>

<!--[[[cog
import glob
def pic_sequence(pix):
    for i, pic in enumerate(pix):
        cls = "slide image"
        if i > 0:
            cls += " fadein"
        if i < len(pix) - 1:
            cls += " fadeout"
        cog.outl('<div class="{}" data-layout="clean"><img src="{}" /></div>'.format(cls, pic))
]]]-->
<!--[[[end]]]-->

<div class="slide image" data-layout="clean"><img src="map2.png" /></div>

<!--[[[cog 
    pic_sequence(
        ['dorn_view.jpg', 'dorn_balcony.jpg', 'dorn_room.jpg', 'dorn_three_stars.jpg', 'dorn_tile_zoom.jpg'] +
        glob.glob('three_stars_0*.png')[:7]
    )
]]] -->
<div class="slide image fadeout" data-layout="clean"><img src="dorn_view.jpg" /></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="dorn_balcony.jpg" /></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="dorn_room.jpg" /></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="dorn_three_stars.jpg" /></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="dorn_tile_zoom.jpg" /></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="three_stars_000_start.png" /></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="three_stars_001_thin.png" /></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="three_stars_002_symmetry.png" /></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="three_stars_003_triangle.png" /></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="three_stars_004_design.png" /></div>
<div class="slide image fadein fadeout" data-layout="clean"><img src="three_stars_005_lined.png" /></div>
<div class="slide image fadein" data-layout="clean"><img src="three_stars_006_chaos.png" /></div>
<!--[[[end]]]-->

<div class="slide section">
    <h1>Matching Points</h1>
</div>


<div class="slide">
    <h1>Ideal</h1>
    <pre class="python">
    Pt = namedtuple("Pt", "x, y")
    zigzags = [
        [Pt(10, 20), Pt(15, 21), Pt(20, 25)],
        [Pt(20, 25), Pt(30, 15), Pt(27, 25), Pt(23, 21)],
    ]
    </pre>
    <pre class="python incremental">
    zz_by_ends = {
        <span class='attn'>Pt(10, 20)</span>: [ 
            [<span class='attn'>Pt(10, 20)</span>, Pt(15, 21), Pt(20, 25)],
        ],
        <span class='attn'>Pt(20, 25)</span>: [
            [Pt(10, 20), Pt(15, 21), <span class='attn'>Pt(20, 25)</span>],
            [<span class='attn'>Pt(20, 25)</span>, Pt(30, 15), Pt(27, 25), Pt(23, 21)],
        ],
        <span class='attn'>Pt(23, 21)</span>: [
            [Pt(20, 25), Pt(30, 15), Pt(27, 25), <span class='attn'>Pt(23, 21)</span>],
        ],
    }
    </pre>
</div>

<div class="slide">
    <h1>&#x261d; Sidebar: dicts</h1>
    <ul>
    <li class="incremental">Maps keys to values</li>
    <li class="incremental">Fast! (more later)</li>
    <li class="incremental">Anything <em>hashable</em> can be a key</li>
    </ul>
    <pre class="python incremental">
    >>> d = {}
    >>> d['hi'] = 'hello'
    >>> d['bye'] = 'goodbye'
    >>> d['hi']
    'hello'
    </pre>

</div>

<div class="slide">
    <h1>Non-string keys</h1>
    <pre class="python">
    >>> d = {}
    >>> d[17] = 23
    >>> d[17]
    23

    >>> d[(1, 2)] = 'a point'
    >>> d[(1, 2)]
    'a point'
    >>> d[(1.0, 2.0)]
    'a point'

    >>> d[Pt(10, 20)] = 'another point'
    >>> d[Pt(10, 20)]
    'another point'
    </pre>
</div>

<div class="slide">
    <h1>BUT: Same point, different values</h1>
    <pre class="python">
    zigzags = [
        [<span class='attn'>Pt(10, 20)</span>, Pt(15, 21), Pt(20, 25)],
        [Pt(20, 25), Pt(30, 15), Pt(27, 25), Pt(23, 21)],
        [<span class='attn'>Pt(10, 20.00001)</span>, Pt(15, 40)],     # !!!   :(
        ...
    ]
    </pre>
    <pre class="python incremental">
    >>> d[Pt(10, 20)] = "hey there"
    >>> d[Pt(10, 20.00001)]
    KeyError: Pt(10, 20.00001)
    </pre>
    <pre class="python incremental">
    >>> Pt(10, 20) == Pt(10, 20.00001)
    False
    >>> 20 == 20.00001
    False
    </pre>
</div>

<div class="slide">
    <h1>Sidebar: floats</h1>
    <ul>
    <li class="incremental">Notoriously fuzzy</li>
    </ul>
    <pre class="python incremental">
    >>> 0.1 + 0.2 == 0.3
    False
    </pre>
    <ul>
    <li class="incremental">Base 10 vs Base 2</li>
    <li class="incremental">1/3 is inexact in base 10</li>
    <li class="incremental">1/10 is inexact in base 2</li>
    <li class="incremental">Not Python-specific</li>
    <li class="incremental">This is different: irrationals</li>
    </ul>
</div>

<div class="slide">
    <h1>Sidebar: special methods</h1>
    <ul>
    <li class="incremental">"dunder" methods: __init__, __len__, __str__, ...</li>
    <li class="incremental">len(x) &nbsp;&nbsp;&nbsp;&#8801;&nbsp;&nbsp;&nbsp; x.__len__()</li>
    <li class="incremental">str(x) &nbsp;&nbsp;&nbsp;&#8801;&nbsp;&nbsp;&nbsp; x.__str__()</li>
    <li class="incremental">x == y &nbsp;&nbsp;&nbsp;&#8801;&nbsp;&nbsp;&nbsp; x.__eq__(y)</li>
    <li class="incremental">"magic"? ☹</li>
    </ul>
</div>

<div class="slide">
    <h1>Fuzzy equality</h1>
    <pre class="python">
    class Pt(namedtuple("Pt", "x, y")):

        def __eq__(self, other):
            x1, y1 = self
            x2, y2 = other
            return (
                math.isclose(x1, x2) and
                math.isclose(y1, y2)
            )
    </pre>
    <ul><li class="incremental">Foreshadowing: this is a bad idea!</li></ul>
</div>

<div class="slide">
    <h1>Sidebar: hashing</h1>
    <ul>
    <li class="incremental">A short-cut for ==</li>
    <li class="incremental">Rules:<ul>
        <li class="incremental">hash() must return an int</li>
        <li class="incremental">x == y &nbsp;&nbsp;&nbsp;&rArr;&nbsp;&nbsp;&nbsp;hash(x) == hash(y)</li>
        <li class="incremental">hash(x) &nbsp;&nbsp;&nbsp;&#8801;&nbsp;&nbsp;&nbsp; x.__hash__()</li>
    </ul></li>
    <li class="incremental">Dicts use the hash to bucket keys together</li>
    <li class="incremental">(Not cryptographic: SHA1, etc)</li>
    </ul>
</div>

<div class="slide">
    <h1>Fuzzy equality</h1>
    <pre class="python">
    class Pt(namedtuple("Pt", "x, y")):

        def __eq__(self, other):
            x1, y1 = self
            x2, y2 = other
            return (
                math.isclose(x1, x2) and
                math.isclose(y1, y2)
            )
    </pre>
    <pre class="python incremental">
        def __hash__(self):
            #  ¯\_(ツ)_/¯
    </pre>
</div>

<div class="slide">
    <h1>Linear search</h1>
    <pre class="python">
    zz_by_ends = [
        (Pt(10, 20),  [..zigzags..] ),
        (Pt(20, 25),  [..zigzags..] ),
        (Pt(23, 21),  [..zigzags..] ),
    ]
    </pre>
    <pre class="python incremental">
    def find_zigzags(p):
        for pt, zigzags in zz_by_ends:
            if p == pt:     # fuzzy!
                return zigzags
    </pre>
</div>

<div class="slide">
    <h1>Dict-like</h1>
    <pre class="python">
    class PointDict:
        def __init__(self):
            # A list of (pt, value) tuples.
            self.items = []

        # pd[pt]  &#8801;  pd.__getitem__(pt)
        def __getitem__(self, pt):
            for key, value in self.items:
                if key == pt:           # fuzzy!
                    return value

            # Didn't find it: make a new list value and add
            # it to the end.
            value = []
            self.items.append((pt, value))
            return value
    </pre>
</div>

<div class="slide">
    <h1>Advice: abstraction</h1>
    <ul>
    <li class="incremental">Aren't sure of the answer?</li>
    <li class="incremental">Get the question right</li>
    <li class="incremental">Hide uncertainty in an abstraction</li>
    </ul>
    <pre class="python incremental">
    pd = PointDict()
    pd[pt1].append(zz1)
    print(pd[pt1])
    </pre>
</div>

<div class="slide image" data-layout="clean">
    <img src="three_stars_007_joined.png" />
</div>

<div class="slide">
    <h1>It works</h1>
    <ul>
    <li>But it's slow</li>
    </ul>
</div>


<div class="slide section">
    <h1>Algorithmic Complexity</h1>
</div>

<div class="slide">
    <h1>Huh?</h1>
    <ul>
    <li class="incremental">Big-O notation</li>
    <li class="incremental">How code slows as data grows</li>
    <li class="incremental">Rough characterization</li>
    </ul>
</div>

<div class="slide">
    <h1>Big-O</h1>
    <ul>
    <li class="incremental">How many steps for N items of data?</li>
    <li class="incremental">Only the biggest component</li>
    <li class="incremental">Ignore constants</li>
    </ul>
</div>


<div class="slide">
    <h1>Linear search: O(N)</h1>
    <ul>
    <li class="incremental">Time is proportional to data</li>
    </ul>
    <pre class="python incremental">
    def __getitem__(self, pt):
        for key, value in self.items:
            if key == pt:
                return value
    </pre>
    <ul>
    <li class="incremental">When self.items doubles in size ...</li>
    <li class="incremental">... time doubles</li>
    <li class="incremental">"time is on the order of N"</li>
    <li class="incremental">O(N)</li>
    </ul>
</div>

<div class="slide">
    <h1>Ideal: O(1)</h1>
    <ul>
    <li class="incremental">Same time no matter how much data!</li>
    <li class="incremental"><tt>mydict[key]</tt> is O(1)</li>
    </ul>
</div>

<div class="slide">
    <h1>The real problem: O(N²)</h1>
    <pre class="python">
    for zz in all_zigzags:
        others = find_zigzags(zz[0])
    </pre>
    <ul>
    <li class="incremental">find_zigzags is O(N)</li>
    <li class="incremental">called N times</li>
    <li class="incremental">O(N²)</li>
    </ul>
</div>

<div class="slide image" data-layout="clean">
    <img src='graph_complexity.png' />
    <!--
    https://graphsketch.com/?eqn1_color=2&eqn1_eqn=x*x&eqn2_color=4&eqn2_eqn=2*x*log(x)&eqn3_color=1&eqn3_eqn=x&eqn4_color=6&eqn4_eqn=7*log(x)&eqn5_color=3&eqn5_eqn=2&eqn6_color=6&eqn6_eqn=&x_min=0&x_max=30&y_min=0&y_max=40&x_tick=100&y_tick=100&x_label_freq=50&y_label_freq=50&do_grid=0&bold_labeled_lines=0&line_width=4&image_w=850&image_h=650
    -->
</div>

<div class="slide">
    <h1>Python time complexities</h1>
    <table style="float:left;margin-right: 2em">
        <tr><th colspan='2'>Lists</td></tr>
        <tr><td><tt>mylist.append(val)  </tt></td><td>O(1)</td></tr>
        <tr><td><tt>mylist[n]           </tt></td><td>O(1)</td></tr>
        <tr><td><tt>val in mylist       </tt></td><td>O(N)</td></tr>
        <tr><td><tt>for val in mylist:  </tt></td><td>O(N)</td></tr>
    </table>
    <table style="float:left">
        <tr><th colspan='2'>Dicts</td></tr>
        <tr><td><tt>mydict[key] = val   </tt></td><td>O(1)</td></tr>
        <tr><td><tt>mydict[key]         </tt></td><td>O(1)</td></tr>
        <tr><td><tt>key in mydict       </tt></td><td>O(1)</td></tr>
        <tr><td><tt>for key in mydict:  </tt></td><td>O(N)</td></tr>
    </table>
</div>

<div class="slide">
    <h1>Be reasonable</h1>
    <ul>
    <li class="incremental">'Fancy algorithms are slow when n is small, and n is usually small.' -- Rob Pike</li>
    <li class="incremental">10-element list? Just do it</li>
    <li class="incremental">100? 1000? O(n) probably OK</li>
    </ul>
</div>


<div class="slide section">
    <h1>Faster Point Matching</h1>
</div>

<div class="slide">
    <h1>Next idea: rounding</h1>
    <pre class="python">
    class Pt(namedtuple("Pt", "x, y")):

        def rounded(self):
            return (round(self.x), round(self.y))

        def __eq__(self, other):
            return self.rounded() == other.rounded()

        def __hash__(self):
            return hash(self.rounded())
    </pre>
    <pre class="python incremental">
    # BUT!
    >>> Pt(11.4999999, 0) == Pt(11.5000001, 0)
    False
    # Because (11.0, 0) != (12.0, 0)
    </pre>
</div>

<div class="slide">
    <h1>Round two ways!</h1>
    <pre class="python">
    def rounded(pt, jitter):
        return round(pt.x + jitter), round(pt.y + jitter)

    def pt_equal(p1, p2):
        return (
            rounded(p1, 0) == rounded(p2, 0) or
            rounded(p1, 0.5) == rounded(p2, 0.5)
        )
    </pre>
    <pre class="python incremental">
    >>> pt_equal(Pt(10.9999999, 0), Pt(11.0000001, 0))
    True
    >>> pt_equal(Pt(11.4999999, 0), Pt(11.5000001, 0))
    True
    </pre>
</div>

<div class="slide">
    <pre class="python medium">
    class PointDict:
        """Like defaultdict(list), with fuzzy Pt's as keys."""
        def __init__(self):
            self.items = {}     # pt -> value
            self.rounds = {}    # pt -> pt

        def __getitem__(self, pt):      <span class="incremental"># O(1)</span>
            val = self.items.get(pt)
            if val is not None:
                return val

            for jitter in [0, 0.5]:
                pt_rnd = rounded(pt, jitter)
                pt0 = self.rounds.get(pt_rnd)
                if pt0 is not None:
                    return self.items[pt0]

            # Not found: make an empty list value
            self.items[pt] = val = []
            for jitter in [0, 0.5]:
                pt_rnd = rounded(pt, jitter)
                self.rounds[pt_rnd] = pt

            return val
    </pre>
</div>

<div class="slide">
    <img style="float:right" width="55%" src="straps.png" />
    <h1>Results</h1>
    <p class="incremental">~2100 points</p>
    <p class="incremental">O(n): <b>20</b> sec</p>
    <p class="incremental">O(1): <b>0.4</b> sec!</p>
</div>

<div class="slide">
    <!-- Slow/Fast {{{ -->
    <div style="float: left; width=50%;">
        <h1 style="margin-top: 0">Slow</h1>
        <div style="position: relative; width=100%">
            <pre class="python small" style="margin-top:0">
                def __init__(self):
                    self.items = []

                def __getitem__(self, pt):
                    for key, value in self.items:
                        if key == pt:
                            return value

                    value = []
                    self.items.append((pt, value))
                    return value
            </pre>
            <div class="incremental" style="margin-top:8em; width:3em;">
                <p class="o_1">&nbsp;&nbsp;O(1)</p>
                <p class="o_n">&nbsp;&nbsp;O(n)</p>
            </div>
            <pre class="python small incremental" style="position: absolute; top:0; left:0; margin-top:0">
                def __init__(self):
                    self.items = []

                def __getitem__(self, pt):
                    <span class="o_n">for key, value in self.items:</span>
                        if key == pt:
                            return value

                    value = []
                    <span class="o_1">self.items.append((pt, value))</span>
                    return value
            </pre>
        </div>
    </div>
    <div style="position: absolute; top:0; right:0;width=50%">
        <h1 style="margin-top: 0">Fast</h1>
        <div style="position: relative; width=100%; padding-right: 2em">
            <pre class="python small" style="margin-top:0">
                def __init__(self):
                    self.items = {}     # pt -> value
                    self.rounds = {}    # pt -> pt

                def __getitem__(self, pt):
                    val = self.items.get(pt)
                    if val is not None:
                        return val

                    for jitter in [0, 0.5]:
                        pt_rnd = rounded(pt, jitter)
                        pt0 = self.rounds.get(pt_rnd)
                        if pt0 is not None:
                            return self.items[pt0]

                    self.items[pt] = val = []
                    for jitter in [0, 0.5]:
                        pt_rnd = rounded(pt, jitter)
                        self.rounds[pt_rnd] = pt

                    return val
            </pre>
            <pre class="python small incremental" style="position: absolute; top:0; left:0; margin-top:0">
                def __init__(self):
                    self.items = {}     # pt -> value
                    self.rounds = {}    # pt -> pt

                def __getitem__(self, pt):
                    val = <span class="o_1">self.items.get(pt)</span>
                    if val is not None:
                        return val

                    for jitter in [0, 0.5]:
                        pt_rnd = rounded(pt, jitter)
                        pt0 = <span class="o_1">self.rounds.get(pt_rnd)</span>
                        if pt0 is not None:
                            return <span class="o_1">self.items[pt0]</span>

                    <span class="o_1">self.items[pt] = val = []</span>
                    for jitter in [0, 0.5]:
                        pt_rnd = rounded(pt, jitter)
                        <span class="o_1">self.rounds[pt_rnd] = pt</span>

                    return val
            </pre>
        </div>
    </div>
    <!-- }}} -->
</div>

<div class="slide">
    <h1>Algorithms!</h1>
    <ul>
    <li>Understand your data structures</li>
    <li>Speed comes from better algorithms</li>
    </ul>
</div>

<div class="slide section">
    <h1>Better Abstraction</h1>
</div>

<div class="slide">
    <h1>One Thing</h1>
    <ul>
    <li class="incremental">"Classes (or functions) should do one thing"</li>
    <li class="incremental">But: what is "one thing"?</li>
    <li class="incremental">Does PointDict do one thing?
        <ul>
            <li class="incremental">Yes: look up values by fuzzy points</li>
            <li class="incremental">No:
                <ol>
                    <li>Defuzz points</li>
                    <li>Look up values</li>
                </ol>
            </li>
        </ul>
    </li>
    </ul>
</div>

<div class="slide">
    <h1>Doing less</h1>
    <pre class="python">
    class Defuzzer:
        def defuzz(self, pt):
            """Return pt, or a previous equal point."""
    </pre>
    <pre class="python incremental">
    >>> defuzz = Defuzzer().defuzz
    >>> defuzz(Pt(1, 2))
    Pt(1, 2)
    >>> defuzz(Pt(3, 4))
    Pt(3, 4)
    >>> defuzz(Pt(1.01, 2))
    Pt(1, 2)
    </pre>
</div>

<div class="slide">
    <pre class="python">
    def defuzz_path(path):
        return [defuzz(pt) for pt in path]

    def defuzz_paths(paths):
        return [defuzz(path) for path in paths]
    </pre>
    <pre class="python incremental">
    def combine_paths(paths):
        paths = defuzz_paths(paths)
        paths_by_ends = defaultdict(list)
        for path in paths:
            paths_by_ends[path[0]].append(path)
            paths_by_ends[path[-1]].append(path)

        for path in paths:
            others = endpoints[path[0]]
            etc()
    </pre>
</div>

<div class="slide section">
    <h1>Representation</h1>
</div>

<div class="slide">
    <h1>Title</h1>
    <p>TODO</p>
    <p>
        List[Point] -> Path
        List[Path] ->  ???
    </p>
    <p>Classes are nicer:
        path_segments(path)  -->  path.segments()
        Fewer imports
        Better organization
    </p>
</div>


<div class="slide section">
    <h1>Other People's Code</h1>
</div>

<div class="slide">
    <h1>Line intersections</h1>
    <pre class="python">
    def segment_intersections(segments):
        isects = defaultdict(list)

        for seg1 in segments:
            for seg2 in segments:
                if seg1 is seg2:
                    continue

                isect_pt = seg1.intersect(seg2)
                if isect_pt is not None:
                    isects[isect_pt].extend([seg1, seg2])

        return isects
    </pre>
</div>

<div class="slide">
    <h1>Better algorithm</h1>
    <img src='wiki-bentley.png' />
    <img class="incremental" src='bentley-zoom.png' 
        style='position:absolute;border: 20px solid #f66; border-radius: 1em; left:1em; top: 8em;'
        />
</div>

<div class="slide image" data-layout="clean">
    <img src='github-ideasman.png' />
</div>

<div class="slide image" data-layout="clean">
    <img src='github-issue.png' />
</div>

<div class="slide image" data-layout="clean">
    <img src='github-pr.png' />
</div>

<div class="slide">
    <h1>Sensitive to rotation</h1>
    <pre>
Failed at rotation 0.0
Failed at rotation 0.16666666666666666
Failed at rotation 0.3333333333333333
Failed at rotation 0.5
Failed at rotation 0.6666666666666666
Failed at rotation 0.8333333333333334
Failed at rotation 1.0
Failed at rotation 1.1666666666666667
1728 intersections
    </pre>
</div>

<div class="slide">
    <h1>Debugging</h1>
    <ul>
    <li class="incremental">Extra code just for debugging</li>
    <li class="incremental">__repr__</li>
    <li class="incremental">assert</li>
    <li class="incremental">if debug:</li>
    </ul>
</div>

<div class="slide">
    <h1>Debugging</h1>
    <!--[[[cog {{{
        with open("debugging_strap.py") as f:
            lines = textwrap.dedent(f.read()).splitlines()
        hiranges = [
            # "debug"
            (20,21), (30,31), (126,133), (136,136), (144,144), (147,162),
            (166,166), (168,174), (227,246), (258,278),
            # "assert"
            (89,89), (178,178), (187,187), (193,193), (201,201),
        ]
        hilines = set()
        for lo, hi in hiranges:
            hilines.update(range(lo, hi+1))
        lines = [quote_html(l[:90]) for l in lines]
        chunk = 100
        result = []
        for start in range(0, len(lines), chunk):
            these_lines = lines[start:start+chunk]
            if these_lines[0][0] == ' ':
                these_lines[0] = '&nbsp;' + these_lines[0][1:]
            style = 'font-size: 19%; width:50em; margin-right: 3em; float: left'
            result.append("<pre class='python' style='{style}'>".format(style=style))
            for lineno, line in enumerate(these_lines, start=start+1):
                if lineno in hilines:
                    line = "<span class='highlight'>" + line + "</span>"
                result.append(line)
            result.append("</pre>")
        cog.outl("\n".join(result))
    ]]] -->
    <pre class='python' style='font-size: 19%; width:50em; margin-right: 3em; float: left'>
    """Strappiness for Zellij."""

    import collections
    import itertools
    import random

    from zellij.debug import should_debug
    from zellij.drawing import Drawing, DrawingSequence
    from zellij.euclid import Point, Segment
    from zellij.intersection import segment_intersections
    from zellij.path_tiler import join_paths, offset_path, path_segments, trim_path


    class Xing:
        def __init__(self, under=None, over=None):
            self.under = under
            self.over = over
            self.over_piece = None

    <span class='highlight'>    def __repr__(self):</span>
    <span class='highlight'>        return f"&lt;Xing under={show_path(self.under)} over={show_path(self.over)}&gt;"</span>

    class Strap:
        def __init__(self, path, width, random_factor=0):
            self.path = path
            if random_factor:
                width *= (1 + random.random() * random_factor)
            self.sides = [offset_path(path, d) for d in [width/2, -width/2]]

    <span class='highlight'>    def __repr__(self):</span>
    <span class='highlight'>        return f"&lt;Strap path={self.path}&gt;"</span>


    def path_pieces(path, segs_to_points):
        """Produce a new series of paths, split at intersection points.

        Yields a series of pieces (paths).  The pieces trace the same line as the
        original path.  The endpoints of the pieces are all intersection points
        in `segs_to_points`, or the endpoints of the original path, if it isn't
        circular.  The pieces are in order along `path`, so consecutive pieces
        end and begin at the same point. If `path` is closed, then the first piece
        returned will begin at the first cut, not at the path's first point.

        """
        # If path is circular, then the first piece we collect has to be added to
        # the last piece, so save it for later.
        collecting_head = (path[0] == path[-1])
        head = None

        piece = []
        for pt in path:
            if not piece:
                piece.append(pt)
            else:
                seg = Segment(piece[-1], pt)
                cuts = segs_to_points.get(seg)
                if cuts is not None:
                    cuts = seg.sort_along(cuts)
                    for cut in cuts:
                        ptcut = Point(*cut)
                        piece.append(ptcut)
                        if collecting_head:
                            head = piece
                            collecting_head = False
                        else:
                            yield piece
                        piece = [ptcut]
                piece.append(pt)

        if head:
            piece = join_paths(piece, head)
        yield piece


    def pieces_under_over(path, segs_to_points, xings):
        """Produce all the pieces of the path, with a bool indicating if each leads to under o
        pieces = list(path_pieces(path, segs_to_points))
        for i, piece in enumerate(pieces):
            xing = xings.get(piece[-1])
            if xing is None:
                continue
            if xing.under == path:
                over = False
            elif xing.over == path:
                over = True
            elif xing.under is not None:
                over = True
            else:
    <span class='highlight'>            assert xing.over is not None</span>
                over = False
            ou = [over, not over]
            if i % 2:
                ou = ou[::-1]
            break
        else:
            ou = [True, False]

        yield from zip(pieces, itertools.cycle(ou))


    </pre>
    <pre class='python' style='font-size: 19%; width:50em; margin-right: 3em; float: left'>
    def strapify(paths, **strap_kwargs):
        """Turn paths intro straps."""

        paths = [tuple(path) for path in paths]

        segments = []
        segs_to_paths = {}
        for path in paths:
            for segment in path_segments(path):
                segments.append(segment)
                segs_to_paths[segment] = path

        points_to_segments = segment_intersections(segments)
        isect_points = list(points_to_segments.keys())

        segs_to_points = collections.defaultdict(list)
        for pt, segs in points_to_segments.items():
            for seg in segs:
                segs_to_points[seg].append(pt)

        points_to_paths = collections.defaultdict(list)
        for isect, segs in points_to_segments.items():
            for seg in segs:
                points_to_paths[isect].append(segs_to_paths[seg])

    <span class='highlight'>    print(f"{len(isect_points)} intersections")</span>
    <span class='highlight'></span>
    <span class='highlight'>    if 0:</span>
    <span class='highlight'>        debug_output(dwgw=DWGW, paths=paths, segments=segments, isects=isect_points)</span>
    <span class='highlight'></span>
    <span class='highlight'>    debug = should_debug("strapify")</span>
    <span class='highlight'>    if debug:</span>
    <span class='highlight'>        dbgdwgs = iter(DrawingSequence(name="debugs_", paths=paths))</span>

        paths_to_do = set(paths)
    <span class='highlight'>    paths_done = set()</span>
        xings = {}      # pt -&gt; xing
        straps = []     # new smaller paths, ending at unders.
        path = None
        while paths_to_do:
            next_paths = set()
            next_paths.add(paths_to_do.pop())
            while next_paths:
    <span class='highlight'>            previous_path = path</span>
                path = next_paths.pop()

    <span class='highlight'>            if debug:</span>
    <span class='highlight'>                dwg = next(dbgdwgs)</span>
    <span class='highlight'>                dwg.draw_segments(segments, rgb=(0, 0, 0), width=1)</span>
    <span class='highlight'>                dwg.draw_paths(paths_done, rgb=(0, 0, 0), width=3)</span>
    <span class='highlight'>                dwg.draw_paths(next_paths, rgb=(.7, .7, 0), width=9)</span>
    <span class='highlight'>                if previous_path:</span>
    <span class='highlight'>                    dwg.draw_path(previous_path, rgb=(1, 0, 0), width=10, dash=[30, 30])</span>
    <span class='highlight'>                dwg.draw_path(path, rgb=(1, 0, 0), width=15)</span>
    <span class='highlight'>                dwg.fill_points([path[0]], rgb=(1, 0, 0), radius=15*3/2)</span>
    <span class='highlight'>                dwg.fill_points([path[1]], rgb=(1, 0, 0), radius=15*2/2)</span>
    <span class='highlight'>                partial_over = [pt for pt, xing in xings.items() if xing.under is None]</span>
    <span class='highlight'>                partial_under = [pt for pt, xing in xings.items() if xing.over is None]</span>
    <span class='highlight'>                dwg.circle_points(partial_over, rgb=(.8, 0, 0), radius=21, width=9)</span>
    <span class='highlight'>                dwg.circle_points(partial_under, rgb=(0, 0, .8), radius=21, width=9)</span>
    <span class='highlight'>                done = [pt for pt, xing in xings.items() if xing.under is not None and xin</span>
    <span class='highlight'>                dwg.circle_points(done, rgb=(0, .8, 0), radius=15, width=3)</span>

                prev_piece = None
                last_cut = None
    <span class='highlight'>            first_piece = True</span>
                for piece, over in pieces_under_over(path, segs_to_points, xings):
    <span class='highlight'>                if first_piece and debug:</span>
    <span class='highlight'>                    dwg.cross_points([piece[0], piece[-1]], radius=20, rgb=(1, 0, 0), widt</span>
    <span class='highlight'>                    dwg.finish()</span>
    <span class='highlight'>                    if 0 and dwg.num &gt; 10:</span>
    <span class='highlight'>                        print()</span>
    <span class='highlight'>                        import sys; sys.exit()</span>
    <span class='highlight'>                    first_piece = False</span>

                    cut = None
                    if over:
    <span class='highlight'>                    assert prev_piece is None</span>
                        prev_piece = piece
                        if last_cut:
                            cut = last_cut
                            xing = xings.get(cut)
                            if xing is None:
                                xing = Xing(under=path)
                                xings[cut] = xing
                            else:
    <span class='highlight'>                            assert xing.under is None or xing.under == path</span>
                                xing.under = path
                            last_cut = None
                    else:
                        if prev_piece:
                            cut = prev_piece[-1]
    <span class='highlight'>                        assert cut == piece[0]</span>
                            strap = Strap(join_paths(prev_piece, piece), **strap_kwargs)
                            straps.append(strap)
                            xing = xings.get(cut)
                            if xing is None:
                                xing = Xing(over=path)
                                xings[cut] = xing
                            else:
    </pre>
    <pre class='python' style='font-size: 19%; width:50em; margin-right: 3em; float: left'>
    <span class='highlight'>&nbsp;                           assert xing.over is None or xing.over == path</span>
                                xing.over = path
                            xing.over_piece = strap
                        else:
                            straps.append(Strap(piece, **strap_kwargs))
                        last_cut = piece[-1]
                        prev_piece = None
                    if cut:
                        for next_path in points_to_paths[cut]:
                            if next_path in paths_to_do:
                                paths_to_do.remove(next_path)
                                next_paths.add(next_path)
                if prev_piece:
                    strap = Strap(prev_piece, **strap_kwargs)
                    straps.append(strap)
                    closed = (path[0] == path[-1])
                    if closed:
                        cut = prev_piece[-1]
                        xing = xings.get(cut)
                        if xing is None:
                            xing = Xing(over=path)
                            xings[cut] = xing
                        else:
                            xing.over = path
                        xing.over_piece = strap

    <span class='highlight'>            paths_done.add(path)</span>
    <span class='highlight'>            if debug:</span>
    <span class='highlight'>                dwg.cross_points([piece[0], piece[-1]], radius=30, rotate=30, rgb=(0, 0, 1</span>
    <span class='highlight'>                dwg.finish()</span>
    <span class='highlight'>                if 0 and dwg.num &gt; 10:</span>
    <span class='highlight'>                    print()</span>
    <span class='highlight'>                    import sys; sys.exit()</span>
    <span class='highlight'></span>
    <span class='highlight'>    if 0:</span>
    <span class='highlight'>        bad = [pt for pt, xing in xings.items() if xing.over_piece is None]</span>
    <span class='highlight'>        debug_output(dwgw=DWGW, paths=paths, segments=segments, isects=bad)</span>
    <span class='highlight'></span>
    <span class='highlight'>    if debug:</span>
    <span class='highlight'>        for strap in straps:</span>
    <span class='highlight'>            dwg = next(dbgdwgs)</span>
    <span class='highlight'>            dwg.draw_segments(segments, rgb=(0, 0, 0), width=1)</span>
    <span class='highlight'>            dwg.draw_path(strap.path, rgb=(1, 0, 0), width=3)</span>
    <span class='highlight'>            for s in strap.sides:</span>
    <span class='highlight'>                dwg.draw_path(s, rgb=(0, 0, 1), width=1)</span>
    <span class='highlight'>            dwg.finish()</span>

        for strap in straps:
            for end in [0, -1]:
                xing = xings.get(strap.path[end])
                if xing is not None:
                    trimmers = xing.over_piece.sides
                    strap.sides = [trim_path(s, end, trimmers) for s in strap.sides]

        return straps


    <span class='highlight'>def debug_output(dwgw=None, paths=None, segments=None, isects=None):</span>
    <span class='highlight'>    dwg = Drawing(paths=paths, name="debug.png")</span>
    <span class='highlight'>    dwg.draw_segments(segments, rgb=(0, 0, 0), width=1)</span>
    <span class='highlight'></span>
    <span class='highlight'>    dup_segments = []</span>
    <span class='highlight'>    segments.sort()</span>
    <span class='highlight'>    for s1, s2 in zip(segments, segments[1:]):</span>
    <span class='highlight'>        if s1 == s2:</span>
    <span class='highlight'>            dup_segments.append(s1)</span>
    <span class='highlight'></span>
    <span class='highlight'>    dwg.draw_segments(dup_segments, rgb=(1, 0, 0), width=7)</span>
    <span class='highlight'></span>
    <span class='highlight'>    if dwgw is not None:</span>
    <span class='highlight'>        with dwg.style(rgb=(0, 0, 1), width=2, dash=[5, 5]):</span>
    <span class='highlight'>            dwg.rectangle(0, 0, dwgw, dwgw)</span>
    <span class='highlight'>            dwg.stroke()</span>
    <span class='highlight'></span>
    <span class='highlight'>    if isects is not None:</span>
    <span class='highlight'>        dwg.circle_points(isects, radius=9, rgb=(0, .5, 0), width=3)</span>
    <span class='highlight'></span>
    <span class='highlight'>    dwg.finish()</span>
    </pre>
    <!--[[[end]]] }}}-->
</div>

<div class="slide image" data-layout="clean">
    <img src='debugs_breath.png' width="50%"/>
</div>

<div class="slide title">
    <h1>The End<span class="incremental">?</span></h1>
</div>


<!-- ** Layouts {{{ -->
<div class="layout" data-name="default">
    <content></content>
    <div class="footer">
        <span class="left">bit.ly<span class='punct'>/</span>bospyvaca</span>
        <span class="right"><span class='punct'>@</span>nedbat</span>
        <hr class="defloat" />
    </div>
</div>

<div class="layout nofooter" data-name="clean">
    <content></content>
</div>

<!-- }}} -->

</body>
</html>
